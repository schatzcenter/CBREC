---
title: "Fire Output Figures"
output: html_document
date: "July 8, 2019"
author: "Max Blasdel"
---

# Purpose:
This script will be for processing outputs of the fire model and creating graphics to display some of the results

Initially run on 9 tile test output *7/8/19*
Running on Sierra outputs *7/15/19*

*Reminder* all values originally in grams/acre
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
options(scipen = 20)
```

# load libraries
```{r message=FALSE}
library(tidyverse)
library(raster)
library(leaflet) # for raster viewing in script
library(gridExtra) # arrange graphs together
library(scales) # display y-axis with commas
```

Load C-BREC custom functions for data processing

```{r}
source("getScenarioFiles.R")
source("sumDataFrames.R")
source("getNames.R")
```

# helper function
```{r}
# convert to grams
poundsToGrams <- function(x) {as.integer(round(x * 907185, digits = 0))}
```

# identify some scenarios of interest

Scenario matrix
```{r}
scenarios_matrix <- read_csv("../../data/SERC/scenarios.csv", col_types = cols())
```

Primary silvicultural treatments
Filter based on criteria to give scenario IDs of interest
```{r}
scenarios_matrix %>% 
        filter(Pulp_Market != "Yes") %>% # filter out pulp markets as these are assumed not to exist for the data
        filter(str_detect(string = Silvicultural_Treatment, pattern = "40_Thin_From_B"))# %>% 
        #filter(Fraction_Piled == 50)

scenarios_matrix %>% 
        filter(Pulp_Market != "Yes") %>% # filter out pulp markets as these are assumed not to exist for the data
        filter(str_detect(string = Silvicultural_Treatment, pattern = "Clearcut"))
```

# Load data
## Choose the scenarios that will be used to compare

Run for either 40% scenario or Clearcut, just change which is commented out
```{r}
# for 40% scenarios
scens <- list(297, 307, 303) # potential for figures

# Reference and Use Cases for raster creation
scens <- list(301, 303)

scens <- list(271, 273) # broadcast all tech, broadcast, no collection

# for clearcut
#scens <- list(675, 679, 681, 685)
#scen_names <- cbrec_ScenarioNameDetails(scens)

scen_names <- cbrec_ScenarioNameDetails(scens) ## NOTE: pressing F2 will bring up the source of the function

# Subtract out wildfire from Rx/Wildfire scenarios?
rx_only <- "yes"
rx_only <- "no"
```

Read in file paths for Sierra region
```{r}
files <- read.csv(paste0(here::here(), "/data/Tiles/Sierra_Subregion_Tiles_clipped_tile-nums.csv"))
```


Get all file directories
```{r}
# Sierra Sub Region 7/15/2019
folders <- cbrec_Dirs(path = "../../data/Tiles/Test_Runs/emissions/Sierra-Subregion", files$X3466)

#folders <- unlist(folders) # i dont know if this step matters

# get all file paths
dfs <- lapply(scens, function(x) {
        cbrec_ScenariosById(folders, id = x, year = 0) # currently only set up to run for one year at a time, will need to change for time series
})
```

## create dataframes for each scenario

Run Scenarios to compare different treatment types
```{r}
## Only considering the Rx burn emissions
# remove the wildfire from scenarios
if(rx_only == "yes") {
        dfs <- lapply(dfs, function(x) {
        out <- cbrec_DataBindTidy(x)

        if(length(out) == 2) {
                return(out[[1]]) # only return first dataframe with prescribed burn emissions
        } else {
                return(out)
        }
        })
     print("Should only be used when comparing prescribed burn scenariso")
}

if(rx_only == "no") {
         ## Summing RX and Wildfire emissions
        dfs <- lapply(dfs, function(x) {
                out <- cbrec_DataBindTidy(x)
        
        if(length(out) == 2) { # check if returned obj is list of RX and wildfire
                out_2 <- cbrec_SumDataFrame(out)
                return(out_2)
        }
        else {
                return(out)       
                }
        })
}
```

# Calculate gross residues and technically recoverable 
## Gross
Gross: load original UW residue data
*Reminder* all values are in per acre
```{r}
# get file name by primary silvicultural treatment
scenarioName <- cbrec_ScenarioName(scens[[1]]) # will be same for all scens
scenarioName <- gsub("-.*", "", scenarioName)

residue_path <- list("No_Action" = "data/UW/residue/NoAction.csv",
                             "Clearcut" = "data/UW/residue/Remove100Percent.csv",
                             "20_Thin_From_Above" = "data/UW/residue/ThinFromAboveRemove20PercentBA.csv",
                             "40_Thin_From_Above" = "data/UW/residue/ThinFromAboveRemove40PercentBA.csv",
                             "60_Thin_From_Above" = "data/UW/residue/ThinFromAboveRemove60PercentBA.csv",
                             "80_Thin_From_Above" = "data/UW/residue/ThinFromAboveRemove80PercentBA.csv",
                             "20_Thin_From_Below" = "data/UW/residue/ThinFromBelowRemove20PercentBA.csv",
                             "40_Thin_From_Below" = "data/UW/residue/ThinFromBelowRemove40PercentBA.csv",
                             "60_Thin_From_Below" = "data/UW/residue/ThinFromBelowRemove60PercentBA.csv",
                             "80_Thin_From_Below" = "data/UW/residue/ThinFromBelowRemove80PercentBA.csv",
                             "20_Proportional_Thin" = "data/UW/residue/ThinProportionalRemove20PercentBA.csv",
                             "40_Proportional_Thin" = "data/UW/residue/ThinProportionalRemove40PercentBA.csv",
                             "60_Proportional_Thin" = "data/UW/residue/ThinProportionalRemove60PercentBA.csv",
                             "80_Proportional_Thin" = "data/UW/residue/ThinProportionalRemove80PercentBA.csv",
                             "Standing_Dead" = "data/UW/residue/Snags.csv")


# load residue data
residue <- read_csv(paste0(here::here(), "/", residue_path[[scenarioName]]), col_types = cols())

# TODO Remove merchantable from calculations
# this requires looking at what is technically recoverable
# tentative fix, this ignores breakage, too simple
# residue %>% 
#         dplyr::select(-Stem_ge9_tonsAcre)

# Set naming for plots
 scenarioName <- gsub("_" ," " ,scenarioName)
 scenarioName <- ifelse(scenarioName != "Clearcut", gsub("0", "0%", scenarioName))
 

dfs <- lapply(dfs, function(x) {
        # filter residue data to include only those in the current tile
        residue <- residue %>% 
                filter(FCID2018 %in% x$FCID2018)
        # check on vars numbers
        residue <- residue %>% 
                mutate_at(.vars = 3:7, .funs = poundsToGrams) %>% # convert pounds to grams in same way as outputs
                dplyr::select(-TPA)
             
        # join gross residue number with original df
        x <- left_join(x, residue)
        
        return(x)
})
```

## Technically recoverable

Take same appraoch as in fire model, load input files and get slope, class into 40/80, multiply gross amounts by recovered_by_size.csv
```{r message=FALSE}
# get tile numbers from folders list
tile_numbers <- gsub(".*/" , "", folders)

# load spatial data to get slope class
spatial_data <- lapply(tile_numbers, function(x) {
        spatial <- readRDS(paste0(here::here(), "/data/Tiles/input/",
                              x, ".rds"))
        
       # remove slopes above 80
         spatial <- spatial %>% 
                filter(Slope < 80)
         
        # specify a slope class
        spatial <- spatial %>% 
                mutate(Slope_Class = case_when(Slope < 40 ~ 40,
                                               T ~ 80)) %>% 
                dplyr::select(x, y, Slope_Class)
})

# bind together
spatial_data <- do.call(rbind, spatial_data)

# join dataframes with slope data
dfs <- lapply(dfs, function(x) {
        left_join(x, spatial_data)
})

# remove unneeded file
rm(spatial_data)
gc(verbose = F)
```

Read in recoverable data frame
I'll go with the recovered as the recoverable amount from the technically recoverable column
*Check on this*
```{r message=FALSE}
recoverable <- read.csv("../../data/SERC/lookup_tables/recovered_by_size.csv", stringsAsFactors = F)

# create mini table of first row from each scenario to get the scenario information
dfs_min <- list()
for (i in 1:length(dfs)) {
        out <- dfs[[i]] %>% 
                filter(row_number() == 1)
        dfs_min[[i]] <- out
}
dfs_min <- do.call(rbind, dfs_min)

# Filter the recoverable down to similar to selected scenarios
recoverable <- recoverable %>% 
        filter(Silvicultural_Treatment %in% dfs_min$Silvicultural_Treatment, # match, this var is most likely same for all comparisons
               Fraction_Piled %in% dfs_min$Fraction_Piled, # match
               Pulp_Market %in% dfs_min$Pulp_Market, # match
               Biomass_Collection == "All Tech Recoverable", # only select recoverable / static percentages
               Burn_Type == "None") # filter down to remove double values

# I want just the scenario that has 'All Tech Recoverable' values
# recoverable <- recoverable %>% 
#         filter(ID %in% x)

# drop unneeded columns
recoverable <- recoverable %>% 
        dplyr::select(-c(ID, 
                         Silvicultural_Treatment, 
                         Fraction_Piled, 
                         Fraction_Scattered,
                         Burn_Type, 
                         Biomass_Collection,
                         Pulp_Market))

# join recoverable percentage
dfs <- lapply(dfs, function(x) {
        left_join(x, recoverable)
})
```

Calculate the new technically recoverable amounts. This is constant based on a percentage from scenario matrix

```{r}
dfs <- lapply(dfs, function (x) {
        x %>%
                mutate(tech_stem_ge9 = Stem_ge9_tonsAcre * Stem_ge9,
                       tech_stem_6t9 = Stem_6t9_tonsAcre * Stem_6t9,
                       tech_stem_4t6 = Stem_4t6_tonsAcre * Stem_4t6,
                       tech_branch = Branch_tonsAcre * Branch,
                       tech_foliage = Foliage_tonsAcre * Foliage) %>% 
                # remove unneeded column
                dplyr::select(-c(Stem_ge9, 
                          Stem_6t9, 
                          Stem_4t6, 
                          Branch, 
                          Foliage,
                          Stem_6t9_tonsAcre,
                          Stem_4t6_tonsAcre,
                          Stem_ge9_tonsAcre,
                          Branch_tonsAcre,
                          Foliage_tonsAcre))
})
gc()
```

End data preparation
Can jump to raster creation or continue with boxplot creation

# Box plot data preparation
## Methane
Set emissions columns of interest
```{r}
# Methane
strs <- c('total_duff_residue_CH4', 
          'total_foliage_residue_CH4', 
          'total_fwd_residue_CH4',
          'total_cwd_residue_CH4',
          'total_pile_CH4')

strs <- grep(paste(strs, collapse = "|"), names(dfs[[1]])) # names will be the same for all list items
```

Sum gases of interest, drop unneeded columns
Normalized by gross
```{r}
# set the names of each scenario
scen_names <- c("Broadcast Burn", "Pile Burn", "Wildfire") #TODO move this to a more logical step

df_out <- list()
for (i in 1:length(dfs)) {
        x <- dfs[[i]] %>% 
                transmute(Methane = base::rowSums(.[strs]),
                          Gross = Stem_6t9_tonsAcre + 
                                  Stem_4t6_tonsAcre + 
                                  Stem_ge9_tonsAcre + 
                                  Branch_tonsAcre + 
                                  Foliage_tonsAcre,
                          Methane = Methane / Gross, # write over methane with normalized value
                  treatment = scen_names[[i]])
        df_out[[i]] <- x
}

df_out <- do.call(rbind, df_out)

ggplot(df_out) +
        theme_minimal() +
        geom_boxplot(aes(treatment, Methane)) +
        labs(y ="Methane / Unit of Mass",
             x = "Burn Type", # TODO change everywhere
             title = '40% Thin From Below') +
        theme(axis.text.x = element_text(angle = 45, hjust = 1),
              text = element_text(size = 14))
```

Output graph for review
```{r}
#ggsave("../../data/Post_process/charts/boxplot_methane.png", dpi = 300)
```

Normalized by technically recoverable

```{r}
# TODO change units for all
# kilograms per metric ton
df_out <- list()
for (i in 1:length(dfs)) {
        x <- dfs[[i]] %>% 
                transmute(Methane = base::rowSums(.[strs]) / 1000, # convert to kilogram
                          Tech = tech_stem_ge9 + 
                                 tech_stem_6t9 + 
                                 tech_stem_4t6 + 
                                 tech_branch + 
                                 tech_foliage ,
                          Tech = Tech / 1000000, # convert technically recoverable to metric tons
                          Methane = Methane / Tech, # write over methane with normalized value
                  treatment = scen_names[[i]])
        df_out[[i]] <- x
}

df_out <- do.call(rbind, df_out)

# scaleFUN <- function(x) sprintf("%.2f", x)

ggplot(df_out) +
        theme_minimal() +
        theme(axis.text.x = element_text(angle = 45, hjust = 1),
      text = element_text(size = 14)) +
        geom_boxplot(aes(treatment, Methane)) +
        # scale_y_continuous(labels = scaleFUN) +
        labs(y = "Methane (kg) / Metric Tons of Recoverable Material",
     x = "Burn Type",
     title = '40% Thin From Below')
```

Output graph for review
```{r}
ggsave("../../data/Post_process/charts/boxplot_methane.png", dpi = 300)
```

## PM 2.5

```{r}
# PM2.5
strs <- c("total_duff_residue_PM2.5",
             "total_foliage_residue_PM2.5",
             "total_fwd_residue_PM2.5",
             "total_cwd_residue_PM2.5",
             "total_pile_vdirty_PM2.5") 

strs <- grep(paste(strs, collapse = "|"), names(dfs[[1]]))
```

Assuming very dirty piles

Technically Recoverable
```{r}
df_out <- list()
for (i in 1:length(dfs)) {
        x <- dfs[[i]] %>% 
                transmute(PM2_5 = base::rowSums(.[strs]) / 1000,
                          Tech = tech_stem_ge9 + 
                                 tech_stem_6t9 + 
                                 tech_stem_4t6 + 
                                 tech_branch + 
                                 tech_foliage ,
                          Tech = Tech / 1000000,
                          PM2_5 = PM2_5 / Tech, # write over emissions number with normalized value
                  treatment = scen_names[[i]])
        df_out[[i]] <- x
}
df_out <- do.call(rbind, df_out)

df_out %>% 
        ggplot() +
        theme_minimal() +
        theme(axis.text.x = element_text(angle = 45, hjust = 1),
              text = element_text(size = 14)) +
        geom_boxplot(aes(treatment, PM2_5)) +
        labs(y = "PM 2.5 (kg) / Metric Tons of Recoverable Material",
             x = "Burn Type",
             title = "40% Thin From Below")
```

Save output
```{r}
#ggsave("../../data/Post_process/charts/boxplot_pm25.png", dpi = 300)
```

Gross available

```{r}
# set the names of each scenario
scen_names <- c("Broadcast Burn", "Pile Burn", "Wildfire")

df_out <- list()
for (i in 1:length(dfs)) {
        x <- dfs[[i]] %>% 
                transmute(PM25 = base::rowSums(.[strs]),
                          Gross = Stem_6t9_tonsAcre + 
                                  Stem_4t6_tonsAcre + 
                                  Stem_ge9_tonsAcre + 
                                  Branch_tonsAcre + 
                                  Foliage_tonsAcre,
                          PM25 = PM25 / Gross, # write over emission with normalized value
                  treatment = scen_names[[i]])
        df_out[[i]] <- x
}
df_out <- do.call(rbind, df_out)

df_out %>% 
        ggplot() +
        theme_minimal() +
        theme(axis.text.x = element_text(angle = 45, hjust = 1),
              text = element_text(size = 14)) +
        geom_boxplot(aes(treatment, PM25)) +
        labs(y =expression("PM 2.5 / Unit of Mass"),
             x = "Treatment Type",
             title = scenarioName)
```

```{r}
#ggsave("../../data/Post_process/charts/boxplot_pm25.png", dpi = 300)
```

# Line/Point graphs

I want total exposed graphed to total methane
Identify Columns of interest

```{r}
# total emissions
strs <- c('total_duff_residue_CH4', 
          'total_foliage_residue_CH4', 
          'total_fwd_residue_CH4',
          'total_cwd_residue_CH4',
          'total_pile_CH4')

strs <- grep(paste(strs, collapse = "|"), names(dfs[[1]])) # names will be the same for all list items
# total exposed
exp_str <- c("total_duff_exposed",
             "total_foliage_exposed",
             "total_fwd_exposed",
             "total_cwd_exposed")

exp_str <- grep(paste(exp_str, collapse = "|"), names(dfs[[1]])) # names will be the same for all list items
```

Prepare data by calculating sums
Differentiate lists by burn_type *this metric may change with diff implementations*
```{r}
df_out <- lapply(dfs, function(x) {
        x %>% 
                transmute(total_exp = base::rowSums(.[exp_str]),
                          total_em = base::rowSums(.[strs]),
                          scen = case_when(Burn_Type == "Broadcast" ~ "Broadcast Burn",
                                           Burn_Type == "Pile" ~ "Pile Burn",
                                           Burn_Type == "None" ~ "Wildfire"))
})

# bind together for plotting
df_out <- bind_rows(df_out)
orig_rows <- nrow(df_out)

df_out <- distinct(df_out) # important for speed

orig_rows - nrow(df_out) # check on how many rows were duplicates
```

Create point or line graph

```{r}
ggplot(df_out) +
        theme_minimal() +
        geom_point(aes(x = total_exp, y = total_em, colour = scen)) +
        labs(x = "Total Exposed",
             y = "Total CH4 Emissions",
             title = scenarioName,
             colour = "Scenarios")
```

Save outputs
```{r}
ggsave("../../data/Post_process/charts/expXch4.png", dpi = 300)
```


# Raster Creation

Set columns of interest
```{r warning=FALSE}
strs_pm <- c("total_duff_residue_PM2.5",
             "total_foliage_residue_PM2.5",
             "total_fwd_residue_PM2.5",
             "total_cwd_residue_PM2.5",
             "total_pile_vdirty_PM2.5") 

# total emissions
strs_meth <- c('total_duff_residue_CH4', 
          'total_foliage_residue_CH4', 
          'total_fwd_residue_CH4',
          'total_cwd_residue_CH4',
          'total_pile_CH4')

# gross <- c('Stem_6t9_tonsAcre', 
#   'Stem_4t6_tonsAcre', 
#   'Stem_ge9_tonsAcre',
#   'Branch_tonsAcre', 
#   'Foliage_tonsAcre')

tech <- c('tech_stem_ge9',
        'tech_stem_6t9', 
        'tech_stem_4t6', 
        'tech_branch',  
        'tech_foliage')
```

# Wildfire emissions scenarios

Create raster objects 
```{r}
r_objs <- lapply(dfs, function(x){
      r_obj <- x %>% 
        transmute(x = x,
                  y = y,
                  emission_value = base::rowSums(.[strs]) / 1000,
                  tech = base::rowSums(.[tech]) / 1000000,
                  emission_value = emission_value / tech) %>% 
              dplyr::select(-tech)
      rasterFromXYZ(r_obj, 
                    res = c(30,30),
                    crs = "+proj=aea +lat_1=34 +lat_2=40.5 +lat_0=0 +lon_0=-120 +x_0=0 +y_0=-4000000 +datum=NAD83 +units=m +no_defs +ellps=GRS80 +towgs84=0,0,0")
})
```

## Compare use and reference
### PM
```{r}
scen_names
# raster order: 
# 1) Use Case Removing all technically recoverable material
# 2) Reference case leaving all materials
# Wildfire effects both scenarios, there is just less material on the ground in the Use case

r_objs <- lapply(dfs, function(x) {
        r_obj <- x %>% 
                transmute(x = x,# maintain coordinates
                          y = y,
                          emission_value = base::rowSums(.[strs_pm]) / 907185) # convert to tons/acre
         rasterFromXYZ(r_obj, 
                    res = c(30,30),
                    crs = "+proj=aea +lat_1=34 +lat_2=40.5 +lat_0=0 +lon_0=-120 +x_0=0 +y_0=-4000000 +datum=NAD83 +units=m +no_defs +ellps=GRS80 +towgs84=0,0,0")
})
```
*note:* think about doing this for year 25 as well 
Output PM rasters

```{r}
r <- r_objs[[1]] # as an example
name_of_raster <- "useCase_pm"
writeRaster(r, paste0("../../data/Post_process/rasters/", name_of_raster, ".tif"), overwrite=T)

r <- r_objs[[2]] # as an example
name_of_raster <- "refCase_pm"
writeRaster(r, paste0("../../data/Post_process/rasters/", name_of_raster, ".tif"), overwrite=T)

rm(r)
gc()
```
### Methane
Repeat for methane, only var to change is strings that are summed

```{r}
r_objs <- lapply(df_out, function(x) {
        r_obj <- x %>% 
                transmute(x = x,# maintain coordinates
                          y = y,
                          emission_value = base::rowSums(.[strs_meth]) / 907185) 
         rasterFromXYZ(r_obj, 
                    res = c(30,30),
                    crs = "+proj=aea +lat_1=34 +lat_2=40.5 +lat_0=0 +lon_0=-120 +x_0=0 +y_0=-4000000 +datum=NAD83 +units=m +no_defs +ellps=GRS80 +towgs84=0,0,0")
})
```

# Histograms

```{r}
r <- r_objs[[1]] # use case

r <- as.data.frame(r, na.rm = T)

ggplot(r) +
        theme_minimal() +
         theme(text = element_text(size = 16),
                axis.text.y = element_text(size = 12)) +
        geom_histogram(aes(emission_value), colour = "#303030", binwidth = .01) +
        labs(x = element_blank(),
             y = element_blank()) +
        scale_y_continuous(labels = comma_format(), limits = c(0,7100000)) +
        scale_x_continuous(limits = c(0,.2)) # limits will have to be changed for each change to data 
```

save output

```{r}
ggsave("../../data/Post_process/charts/useMeth_hist.png", dpi = 600, width = 4, height = 3)
```


```{r}
r <- r_objs[[2]] # ref case

r <- as.data.frame(r, na.rm = T) 

ggplot(r) +
        theme_minimal() +
         theme(text = element_text(size = 16),
               axis.text.y = element_text(size = 12)) +
        geom_histogram(aes(emission_value), colour = "#303030", binwidth = .01) +
        labs(x = element_blank(),
             y = element_blank()) +
        scale_y_continuous(labels = comma_format(), limits = c(0,7100000)) +
        scale_x_continuous(limits = c(0,.2)) # limits will have to changed for each data iteration unless becomes programmed 
        #TODO
```

save output
```{r}
ggsave("../../data/Post_process/charts/refMeth_hist.png", dpi = 600, width = 4, height = 3)
```


Save output
```{r}
r <- r_objs[[1]] # as an example
name_of_raster <- "useCase_meth"
writeRaster(r, paste0("../../data/Post_process/rasters/", name_of_raster, ".tif"), overwrite=T)

r <- r_objs[[2]] # as an example
name_of_raster <- "refCase_meth"
writeRaster(r, paste0("../../data/Post_process/rasters/", name_of_raster, ".tif"), overwrite=T)

rm(r)
gc()
```


Inspect results
```{r}
plot(r_objs[[1]])
```


Using leaflet to create interactive map, has about a 4.5 M pixel limit
```{r}
# set raster object
r <- r_objs[[1]]

pal <- colorNumeric(c("#d7191c","#fdae61","#ffffbf","#abd9e9", "#2c7bb6"), values(r),
  na.color = "transparent", reverse = T)

# sometimes needs to be callled twice
leaflet() %>% 
        addTiles() %>% 
        addProviderTiles(providers$CartoDB.Positron) %>% 
        addRasterImage(r, opacity = 0.8, colors = pal) %>% 
        addLegend(pal = pal,
                  values = values(r))
```

# Output rasters for use in a GIS

```{r}
r <- r_objs[[1]] # as an example
name_of_raster <- "broadcast_pm"
writeRaster(r, paste0("../../data/Post_process/rasters/", name_of_raster, ".tif"), overwrite=T)

r <- r_objs[[2]] # as an example
name_of_raster <- "pileBurn_pm"
writeRaster(r, paste0("../../data/Post_process/rasters/", name_of_raster, ".tif"), overwrite=T)

r <- r_objs[[3]] # as an example
name_of_raster <- "wildfire_pm"
writeRaster(r, paste0("../../data/Post_process/rasters/", name_of_raster, ".tif"), overwrite=T)
dfs[[2]]
```


