---
title: "post process fire output"
output: html_document
author: "Max Blasdel"
date: "May 30th, 2019"
---
... in progress

# Purpose
Examine outputs from fire model test run

# Outcomes
Establish dir function to seperate outputs by treatment type etc...

Create histograms/boxplot/spatial output of key attributes

Compare scenarios across time series

Summarize emissions numbers
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
options(scipen = 20)
```

load relevant packages
```{r message=FALSE}
library(tidyverse)
library(raster)
```

# Define constants

Cell size: 900 square meters
Square meters per acre: 4046.86

```{r}
acres_per_cell <- 900 / 4046.86
```

Find all output folders
Five 'runs' or groups of tiles were run on May 30, 2019. These will be examined seperately.

```{r}
# Tiles that were run May 30 2019
# path to all tiles *updated June 6 2019
path <- "../../data/Tiles/Test_Runs/emissions"
```

Define runs. Each run is a slice latitudinally 
```{r}
Run1 <- seq(304, 368)
Run2 <- seq(2139,2233)
Run3 <- seq(5912,6056)
Run4 <- seq(8780,8845)
Run5 <- seq(10888,10945)
```

Read in scenario matrix for reference

```{r}
scenarios_matrix <- read_csv("../../data/SERC/scenarios.csv", col_types = cols() )

View(scenarios_matrix)
```

# functions

Dir function for getting all folders of interest and second dir function to find all rds files in each folder for a given scenario
```{r}
# accepts vector and retrieves all tile directories corresponding to vector
getDirs <- function(path, start, end) {
  f <- dir(path, 
           pattern = paste0("^", as.character(seq(start, end)), "$", collapse = "|"),
           full.names = T)
  return(f)
}

# Uses scenario Id and year of interest
# year 0 is treated differently due to the first and second burns
#TODO figure out how to deal with first and second burns
# I think I want to sum the first and second
getScenariosId <- function(path, id, year) {

  f <- dir(path,
           pattern =paste("first-.*-.*-",id, "-", "\\d+","-",year,".rds$", sep = ""),
           recursive = T,
           full.names = T)
  # account for wildfire after RX burn
  if (year == 0) {
   s <- dir(path,
           pattern =paste("second-.*-.*-",id, "-", "\\d+","-",year,".rds$", sep = ""),
           recursive = T,
           full.names = T)
   f <- dir(path,
           pattern =paste("first-.*-.*-",id, "-", "\\d+","-",year,".rds$", sep = ""),
           recursive = T,
           full.names = T)
   
   if (length(s) == 0) { # 'second' burn does not appear in every year zero scenario
           return(f)
        } else {
                message("This runs contains a second burn and I haven't figured out a way to deal with this yet.")
        return(list(f,s)) # I want these as seperate lists     
          }
        } else {
return(f)
          }
}

# function for getting scenario name
# requires scenario matrix
getScenarioName <- function(id) {
        if (!exists('scenarios_matrix')) {
        scenarios_matrix <- read_csv("../../data/SERC/scenarios.csv", col_types = cols())
        }
        f <- scenarios_matrix %>% 
              dplyr::filter(ID == id) %>% 
                paste(collapse = "-")
        f <- sub("\\d+.", "", f)
        return(f)
}

# Without accounting for the second burn scenarios
# getScenariosIdSimp <- function(path, id, year) {
# 
#   f <- dir(path,
#            pattern =paste("-", id, "-", "\\d+","-",year,".rds$", sep = ""),
#            recursive = T,
#            full.names = T)
#         
#   return(f)
# }

# Functions to bind data together, either with column drops or no column drops
getDataBindSimple <- function (data) {
        d <- bind_rows(lapply(data, read_rds)) %>% 
        dplyr::select(-c("fuelbed_number",
                  "FCID2018",
                  "ID",
                  "Silvicultural_Treatment",
                  "Burn_Type",
                  "Fraction_Piled",
                  "Fraction_Scattered",
                  "Biomass_Collection",
                  "Pulp_Market",
                  # "Secondary_Burn", # removing this var since it is important for year 0
                  "Year"))
        return(d)
}

# with no drop of columns
getDataBindAll <- function (data) {
        d <- bind_rows(lapply(data, read_rds))
        return(d)
}

# Wrapper function to call a dataframe by id and year from a given test slice
getDataWrapper <- function(path, runN, id, year, all = F) {
        
        start <- min(runN)
        end <- max(runN)

        run <- getDirs(path = path, start = start, end = end)
        
        t <- getScenariosId(path = run, id = id, year = year)
        
        # choose which data bind function to use
        if (all == F){
                t <- getDataBindSimple(t)        
        } else {
                t <- getDataBindAll(t)
        }
        
        n <- getScenarioName(id)
        
        return(list(t, n))
}
```

# Speed test
This is a test knowing the full dataset will be much larger

In summary the readr::read_rds() and dplyr::bind_rows() was significantly faster, although I beleive these functions use more memory than the base::readRDS 

```{r}
# start <- Sys.time()
# do.call(rbind,lapply(scen, readRDS)) # slower
# Sys.time() - start

# start <- Sys.time()
# bind_rows(lapply(scen, read_rds)) # faster
# Sys.time() - start
```

# plot functions
```{r}
histoGraph <- function(data, var, title = FALSE, subtitle = FALSE) {
        
        if(title == T) {subtitle = F} # title overrides subtitle
        
        g_title <- data[[2]]
        
        g <- ggplot(data[[1]]) +
                theme_minimal() +
                geom_histogram(aes_string(var), bins = 50)
                
         if(title == TRUE){
                g <- g + labs(title = g_title)
         } else if(subtitle == TRUE) {
                g <- g + labs(subtitle = g_title)
         }
        g
}
```



# Look at data

Bind data together and create graphs

Reference the C-BREC fire model README.md for column header definitions

# Create plots to show data

#1 Gross CO2 for each tile of Run3 
1) CO2 for each tile on a single run *will require non-wrapper function* *use run3*

```{r}
# get all folders
t <- getDirs(path, start = min(Run3), end = max(Run3))

# get all rds files associated with an id. Arbitrary id chosen
t <- getScenariosId(path = t, id = 663, year = 0)

# mutate data into correct form for ggplot
out <- list()
for (i in 1:length(t)) {
        out[[i]] <- read_rds(t[i]) %>% 
                transmute(gross_CO2 = acres_per_cell * (total_duff_residue_CO2 +
                       total_foliage_residue_CO2 +
                       total_fwd_residue_CO2 +
                       total_cwd_residue_CO2),
                        tile = str_split(t[i], pattern = "/")[[1]][7]) # get tile number from data
}
out <- do.call(rbind, out)
```

Create box and whisker
```{r}
# ggplot(out) +
#         geom_boxplot(aes(tile, gross_CO2)) +
#         theme(axis.text.x = element_text(angle = 45, hjust = 0))
```

In Q look at some of the tiles to determine approximate location to make the x-axis make more sense.

Plot out data. A raster output of this data also exists.
```{r}
ggplot(out) +
        geom_boxplot(aes(tile, gross_CO2)) +
        theme(axis.text.x = element_text(angle = 45, hjust = 1),
              axis.title.x = element_blank()) +
        labs(y= "Gross CO2 tons per cell") +
        scale_x_discrete(breaks = c(5912, 5927, 5947, 5964, 5976, 5997, 6016, 6052), 
                         labels = c("Lompoc",
                                    "San Luis Obispo",
                                    "Eastside Coast Range",
                                    "Central Valley",
                                    "Sierra Foothills",
                                    "Lake Tahoe",
                                    "Honey Lake",
                                    "Modoc NF"))
```


#2 Gross CO2 for each Slice
2) Create box and whisker with all runs.
   This requires data to be in diff format.

## Boxplot helper functions
```{r}
# for labeling sample size, y argument changes height, may need to be adjusted for individual plots
give.n <- function(x){
   return(c(y = -0.3, label = length(x)))
}

# for extending the whisker lengths
f <- function(x) {
  r <- quantile(x, probs = c(0.01, 0.25, 0.5, 0.75, 0.99)) # these numbers show the % range, anything outside the numbers will not be shown on the plot
  names(r) <- c("ymin", "lower", "middle", "upper", "ymax")
  r
}

# create total emissions by size class
getGrossEmissions <- function(data) {
        data <- data %>% 
        mutate(gross_CO2 = acres_per_cell * (total_duff_residue_CO2 +
                       total_foliage_residue_CO2 +
                       total_fwd_residue_CO2 +
                       total_cwd_residue_CO2),
                gross_CH4 = acres_per_cell * (total_duff_residue_CH4 +
                       total_foliage_residue_CH4 +
                       total_fwd_residue_CH4 +
                       total_cwd_residue_CH4),
                gross_PM2.5 = acres_per_cell * (total_duff_residue_PM2.5 +
                       total_foliage_residue_PM2.5 +
                       total_fwd_residue_PM2.5 +
                       total_cwd_residue_PM2.5))
        return(data)
}

# wrapper to format data correctly
boxPlotWrapper <- function(run, num, id, year) {
        data <- getDataWrapper(path = path, runN = run, id = id, year = year)
        # calculate gross emissions values, changed to transmute
        data[[1]] <- getGrossEmissions(data[[1]])
        # add run identifier
        data[[1]] <- data[[1]] %>% 
                mutate(run = as.character(num))
        return(data[[1]])
}
```

Define variables of interest and generate box plot data in correct format

```{r}
id = 170
year = 0

r1 <- boxPlotWrapper(Run1, num = 1, id, year)
r2 <- boxPlotWrapper(Run2, num = 2, id, year)
r3 <- boxPlotWrapper(Run3, num = 3, id, year)
r4 <- boxPlotWrapper(Run4, num = 4, id, year)
r5 <- boxPlotWrapper(Run5, num = 5, id, year)

# quick estimate of density of data for each slice
rows_per_tile <- data_frame(
        r1 %>% nrow() / length(Run1),
        r2 %>% nrow() / length(Run2),
        r3 %>% nrow() / length(Run3),
        r4 %>% nrow() / length(Run4),
        r5 %>% nrow() / length(Run5)) %>% 
        gather()

rows_per_tile

box_data<- rbind(r1, r2, r3, r4, r5)
```

Create graphs

```{r}
# Define title of graphs
title <- getScenarioName(id)

# with extended whiskers
ggplot(box_data, aes(run, gross_CO2)) +
        theme_minimal() +
        theme(text = element_text(size = 15)) +
        stat_summary(fun.data = f, geom = "boxplot") + # whiskers controlled by fun.data = f // see f
        labs(title = title, subtitle = paste("For Year: ",as.character(year)),
             y = "Gross CO2 tons per cell") +
        stat_summary(fun.data = give.n, 
                     geom = "text", 
                     position = "dodge",
                     size = 4)

# shows outliers
ggplot(box_data, aes(run, gross_CO2)) +
        theme_minimal() +
        theme(text = element_text(size = 15)) +
        geom_boxplot() +
        labs(title = title, subtitle = paste("For Year: ",as.character(year)),
             y = "Gross CO2 tons per cell") +
        stat_summary(fun.data = give.n, 
                     geom = "text", 
                     position = "dodge",
                     size = 4)

#This losses some data and can distort some of the data
# changing the y axis to show the bulk of the data more clearly
# probably should not use right now
ggplot(box_data, aes(run, gross_CO2)) +
        theme_minimal() +
        theme(text = element_text(size = 15)) +
        geom_boxplot() +
        labs(title = title, subtitle = paste("For Year: ",as.character(year)),
             y = "Gross CO2 tons per cell") +
        stat_summary(fun.data = give.n, 
                     geom = "text", 
                     position = "dodge",
                     size = 4) +
        scale_y_continuous(breaks = seq(0,0.5, 0.1), limits = c(0,10)) #TODO should set programmatically
```

Given the large amount of outliers view a historgram of the data
```{r}
box_data %>% 
        filter(run == '1') %>% 
        ggplot(aes(gross_CO2))+
        theme_minimal() +
        geom_histogram() +
         labs(title = title, subtitle = paste("For Year: ",as.character(year)),
             y = "Frequency", x= "Gross CO2 tons per cell")

# Zoom in to lower limits
box_data %>% 
        filter(run == '1') %>% 
        filter(gross_CO2 <= 0.2) %>% # filtering based on gross CO2 value
        ggplot(aes(gross_CO2))+
        theme_minimal() +
        geom_histogram() +
         labs(title = title, subtitle = paste("For Year: ",as.character(year)),
             y = "Frequency", x= "Gross CO2 tons per cell")


# Zoom in to lower limits
box_data %>% 
        filter(run == '1') %>% 
        filter(gross_CO2 <= 0.2) %>% 
        ggplot(aes(gross_CO2))+
        theme_minimal() +
        geom_histogram(binwidth = .001) +
         labs(title = title, subtitle = paste("For Year: ",as.character(year)),
             y = "Frequency", x= "Gross CO2 tons per cell")
```


Put all the histograms together
```{r}
histWrapper <- function(runNum) {
        g <- box_data %>% 
                filter(run == as.character(runNum)) %>% 
                filter(gross_CO2 <= 0.2) %>% 
                ggplot(aes(gross_CO2))+
                theme_minimal() +
                geom_histogram(binwidth = .001) +
                labs(y = "Frequency", x= "Gross CO2 tons per cell")
        
        return(g)
}

text = title

t <- ggplot() + 
  annotate("text", x = 4, y = 25, size=3, label = text) + 
  theme_bw() +
  theme(panel.grid.major=element_blank(),
    panel.grid.minor=element_blank(),
    axis.title = element_blank(),
    axis.text.x = element_blank(),
    axis.text.y = element_blank())
        
g <- gridExtra::arrangeGrob(histWrapper(1), histWrapper(2), histWrapper(3), histWrapper(4),histWrapper(5),t, ncol = 3)

plot(g)
```

Output file
Can be hard to read in R studio
```{r}
#ggsave("out/histo.png",g, dpi = 300, width = 12)
```


#3 Mass Exposed Time Series

box plot of mass exposed
data for one scenario and every year of that scenario put into similar format as above

## Helper functions
```{r}
# mass exposed to wildfire
getGrossFire <- function(data) {
        data <- data %>% 
        transmute(gross_exposed = acres_per_cell * (total_duff_exposed +
                       total_foliage_exposed +
                       total_fwd_exposed +
                       total_cwd_exposed),
                gross_consumed = acres_per_cell * (total_duff_consumed +
                       total_foliage_consumed +
                       total_fwd_consumed +
                       total_cwd_consumed))
        return(data)
}

exposedFireWrapper <- function (run, year, id) {
        
        data <- getDataWrapper(path = path, runN = RunN, id = id, year = year)
        data[[1]] <- getGrossFire(data[[1]])
        data[[1]] <- data[[1]] %>% 
                mutate(year = year)
        
        return(data[[1]])
}
```

Run data and get in correct form
```{r}
RunN = Run1
id = 169
title = getScenarioName(id)

r1 <- exposedFireWrapper(run = RunN, id = id, year = 0)
r2 <- exposedFireWrapper(run = RunN, id = id, year = 25)
r3 <- exposedFireWrapper(run = RunN, id = id, year = 50)
r4 <- exposedFireWrapper(run = RunN, id = id, year = 75)
r5 <- exposedFireWrapper(run = RunN, id = id, year = 100)

expData <- rbind(r1, r2, r3 ,r4, r5)
rm(r1,r2,r3,r4,r5)
```


```{r}
# with extended whiskers
ggplot(expData, aes(year, y = gross_exposed)) +
        theme_minimal() +
        theme(text = element_text(size = 15)) +
        stat_summary(fun.data = f, geom = "boxplot") +
        labs(title = title,
             y = "Gross Exposed tons per cell") +
        scale_x_continuous(breaks = seq(0,100,25))

# Showing outliers
ggplot(expData, aes(year, y = gross_exposed)) +
        theme_minimal() +
        theme(text = element_text(size = 15)) +
        geom_boxplot(aes(group = year)) +
        labs(title = title,
             y = "Gross Exposed tons per cell") +
        scale_x_continuous(breaks = seq(0,100,25))

```

#4 Raster function

Develop function to read in data and output raster object based on some specifications

```{r}
data <- getDataWrapper(path, runN = Run3, id = 661, year = 25, all = F)

data <- getGrossEmissions(data[[1]])

# define rows of interest
rows_of_interest <- c("x", "y", "gross_CO2")

d <- data %>%
        select(rows_of_interest)

# raster from xyz
r <- raster::rasterFromXYZ(d, res = c(30,30), crs = "+proj=aea +lat_1=34 +lat_2=40.5 +lat_0=0 +lon_0=-120 +x_0=0 +y_0=-4000000 +datum=NAD83 +units=m +no_defs +ellps=GRS80 +towgs84=0,0,0")

# test plot
raster::plot(r)

getScenarioName(661)

#writeRaster(r, "out/raster/run3.tif")
```


#5 Comparison function

Function to compare a metric across two different scenarios. Could be most useful for collection / no collection with all other variables constant, etc... 

Refer to scenario matrix.
```{r}
t <- getDataWrapper(path, runN = Run1, id = 491, year = 0, all = F)

t1 <- getDataWrapper(path, runN = Run1, id = 493, year = 0, all = F)

# titles for histos
g_title <- t[[2]] # title is graph on left
g_subtitle <- t1[[2]] # on right

var = "total_cwd_exposed"

# create graphs
h1 <- ggplot(t1[[1]]) +
                theme_minimal() +
                geom_histogram(aes_string(var), bins = 50)

h <- ggplot(t[[1]]) +
                theme_minimal() +
                geom_histogram(aes_string(var), bins = 50) +
                labs(title = g_title, subtitle = g_subtitle)
```

plot
*saving plots*
arrangeGrob() outputs a gtable object which can be saved with ggsave(path, object, options...)
grid.arrange() will display the output without creating an object. Method will not save the arrangment (only saves one graph).

```{r}
g <- gridExtra::arrangeGrob(h, h1, ncol = 2)
```


Test Save file and display
```{r}
ggsave("out/hist_comp.png",g ,dpi = 400, width = 12)
```


#6 Size test

Bind results from one run together and test size.
Bind together results from same run but drop unneeded columns and convert decimal to integer, apply significant figures

Data as is. For one scenario and all runs bound together
```{r}
runs <- list(Run1, Run2, Run3, Run4, Run5)

data <- lapply(runs, function(x) {
        d <- getDataWrapper(path = path, runN = x, id = 169, year = 0, all = T)
        return(d[[1]])
})

# bind all together
data <- rbind_all(data)

#saveRDS(data, "out/size_test/as_is.RDS")
```

Convert to integer method

```{r}
runs <- list(Run1, Run2, Run3, Run4, Run5)

# get all data, returns just the df
data <- lapply(runs, function(x) {
        d <- getDataWrapper(path = path, runN = x, id = 169, year = 0, all = T)
        return(d[[1]])
})

# bind all together
data <- bind_rows(data)

# if other columns are negated from analysis
all_cols <- str_subset(names(data), pattern = "^x|^y", negate = T)

# function to be applied in mutate 
fun <- function(x) {
        x <- x * 1000 * 1000
        as.integer(x)
}

# set up predetermined columns of interest
some_cols <- c(14:77)


data <- data %>% mutate_at(.vars = some_cols, .funs = fun)
#saveRDS(data, "out/size_test/changed_all_cols.RDS")
```

# Benchmark testing
```{r}
library(microbenchmark)

# get all runs
t1 <- getDirs(path = path, start = min(Run1), end = max(Run1))
t2 <- getDirs(path = path, start = min(Run2), end = max(Run2))
t3 <- getDirs(path = path, start = min(Run3), end = max(Run3))
t4 <- getDirs(path = path, start = min(Run4), end = max(Run4))
t5 <- getDirs(path = path, start = min(Run5), end = max(Run5))

t <- c(t1, t2, t3, t4, t5)

# get all paths
t <- getScenariosId(path = t, id = 668, year = 50)

## Helper functions
# predetermined the columns of interest
some_cols <- c(14:77)

fun <- function(x) {
        x <- as.integer(x*1000*1000)
        return(x)
}

myFun <- function(x){ read_rds(x) %>% 
        mutate_at(.vars = some_cols, .funs = fun)
}

# bind all data together normally
data <- lapply(runs, function(x) {
        d <- getDataWrapper(path = path, runN = x, id = 668, year = 50, all = T)
        return(d[[1]])
})

# Benchmarking four things: 
# 1) convert data once it has been already converted to a single df
# 2) converting each rds seperately and binding together
# 3) Convert each .rds seperatly, most similar to what I think would be in the fire model
# 4) Convert one .rds
start <- Sys.time()
        data <- data %>% mutate_at(.vars = some_cols, .funs = fun)
        # bind_rows(lapply(t, myFun)),
        # t <- lapply(t, myFun)
        # read_rds(t[1]) %>% mutate_at(.vars = some_cols, .funs = fun)
Sys.time() - start

sample.int(999, 1)

addFun <- function(x){x+sample.int(999,1)}

data <- data %>% 
        mutate_at(.vars = some_cols, .funs = addFun)

data
# saveRDS(data, "out/size_test/withRandData.rds")

start <- Sys.time()
myFun(t[1])
Sys.time() - start

tester <- read_rds(t[1])

microbenchmark(tester %>% mutate_at(.vars = some_cols, .funs = fun))
```
about 21 seconds to read_rds and mutate for 427 files totaling 5+ M rows

to convert binded dataframe takes 2.3 seconds

to read and convert one file is 0.044 seconds


How many pixels have 10^8 grams of residues

Compare numbers
```{r}
#overall size written to disk
77.5 / 126.4

1 - 79.6 / 126.4

# size in memory
# whole
3
# all cols int
1.7
```












# Histograms function
```{r}
histoGraph <- function(data, var, label, title = TRUE) {
        
        g_title <- data[[2]]
        
        g <- ggplot(data[[1]]) +
                theme_minimal() +
                geom_histogram(aes(var), bins = 50) +
                xlab(label)
        
         if(title == TRUE){
            g <- g + labs(title = g_title)
            
         }
        g
}

histoGraph(data, data[[1]]$total_fuel_consumed, label = "Fuel Consumed", title = F)
```

Graph some of these
*not sure if useful*
```{r}
a <- histoGraph(dat, dat$all_CO2, label = "All CO2 Emissions per Cell", title = T)
b <- histoGraph(dat, dat$all_CH4, label = "All CH4 Emissions per Cell", title = F)
c <- histoGraph(dat, dat$all_PM2.5, label = "All PM2.5 Emissions per Cell", title = F)

gridExtra::grid.arrange(a,b,c, ncol = 3)
```

# scratch
All values in tons / acre calculate total acreage based on 30 x 30 cell size
Each row of data is a cell
```{r}
getSummaryStats <- function (data, year) {
        data %>%
        transmute(CO2 = all_CO2 * acres_per_cell,
               CH4 = all_CH4 * acres_per_cell,
               PM2.5 = all_PM2.5 * acres_per_cell,
               area = acres_per_cell) %>% 
        summarise_all(sum) %>% 
                `rownames<-`(year)
}

getSummaryStats(data, 50)
```


