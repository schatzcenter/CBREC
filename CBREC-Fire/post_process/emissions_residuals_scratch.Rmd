---
title: "emissions and residues explore"
author: "Max Blasdel"
date: "6/13/2019"
output: html_document
---

# Purpose
Explore the outputs of three tiles for emissions and residual material 
Looking specifically for cells which show foliage exposed but nothing else

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


libraries
```{r message=FALSE}
library(tidyverse)
library(data.table)
```

Separate paths for emissions and residuals

```{r}
em_path <- "../../data/Tiles/dev_test/emissions"

res_path <- "../../data/Tiles/dev_test/residual_fuels"

scenarios_matrix <- read_csv("../../data/SERC/scenarios.csv", col_types = cols() )

# path to 1/3 run
path <- "data/Tiles/output/emissions"
```

functions

```{r}
getDirs <- function(path, start, end) {
  f <- dir(path, 
           pattern = paste0("^", as.character(seq(start, end)), "$", collapse = "|"),
           full.names = T)
  return(f)
}

getScenariosIdSimp <- function(path, id, year) {

  f <- dir(path,
           pattern =paste("-", id, "-", "\\d+","-",year,".rds$", sep = ""),
           recursive = T,
           full.names = T)

  return(f)
}

getDataBindAll <- function (data) {
        library(tidyverse)
        d <- bind_rows(lapply(data, read_rds))
        return(d)
}

getScenarioName <- function(id) {
        if (!exists('scenarios_matrix')) {
        scenarios_matrix <- read_csv("../../data/SERC/scenarios.csv", col_types = cols())
        }
        f <- scenarios_matrix %>% 
              dplyr::filter(ID == id) %>% 
                paste(collapse = "-")
        f <- sub("\\d+.", "", f)
        return(f)
}
```

Wrote post-process functions into their own file
All use the cbrec_* prefix

```{r}
source("getScenarioFiles.R")
```

Get all folders with files and load data for emissions and residual fuels

```{r}
cbrec_ScenarioName(id = 665)

year = 0
id = 665

dat <- cbrec_Dirs(path = em_path, start = 111, end = 111)

dat <- cbrec_ScenariosById(dat, id, year)

dat <- cbrec_DataBindTidy(dat)
```

# Foliage not being consumed

```{r}
# calculate metric, should never be 0
t <- dat %>% 
        mutate(metric = total_fwd_consumed / total_fwd_exposed)

t %>% 
        filter(metric == 0)# %>% select(fuelbed_number) %>% unique()

t$metric %>% unique()
```

# Look at large 1/3 run of state
Compare row numbers

```{r}
id = 665
year = 0

folds <- getDirs(path = path, start = 111, end = 111)
folds <- getScenariosIdSimp(folds, id = id, year = year)
dat <- getDataBindAll(folds)

nrow(dat)

dat$fuelbed_number
r <- dat %>% 
        select(x,y,fuelbed_number) %>% 
        raster::rasterFromXYZ(res = c(30,30), crs = "+proj=aea +lat_1=34 +lat_2=40.5 +lat_0=0 +lon_0=-120 +x_0=0 +y_0=-4000000 +datum=NAD83 +units=m +no_defs +ellps=GRS80 +towgs84=0,0,0 ")

# write out just to look for cutout from lost data
# raster::writeRaster(r, filename = "bigRast.tif")
```

# Mass balance equations
Load original UW data

```{r}
# bring in df as generated by the load_data() from fire model
fuel_df

# read in original UW dataset. Same one that feeds into CBREC
origResidues <- fread("../../data/SERC/Residue_by_treatment.csv")

origResidues <- origResidues[Treatment == 'TP20',]

origResidues <- origResidues[FCID2018 %in% fuel_df$FCID2018]
origResidues <- as.data.frame(origResidues)

origResidues <- left_join(fuel_df[,2], origResidues, by = "FCID2018")
```

As the fuel_df changes I want to check that the masses are the same
Initial check

```{r}
# column names of interest
cols <- colnames(fuel_df)
cols <- str_subset(cols, pattern = "tonsAcre")

diff_values

vals <- fuel_df %>% 
        select(cols)

data.frame(as.matrix(origResidues[,3:7]) - as.matrix(vals))
```



# wind correction bug
Load input data with wind values

```{r}
inputs <- dir("../../data/Tiles/input", full.names = T)
res_dir <- dir("../../data/UW/residue", full.names = T)

# load res data
res <- fread(res_dir[2]) %>% select(FCID2018, TPA) # clear cut, all zero TPA
#res <- read.csv(res_dir[1]) %>% select(FCID2018, TPA) # no action, Maximum TPA
```   

Trying to find the error eval

```{r}
out <- list()

for (i in 1732:2031) {
        dt <- read_rds(inputs[i]) %>% 
                as.data.table()
        
        setkey(dt, FCID2018)
        # join TPA with weather data
        dt <- merge(dt, res)
        
        # I need TPA for the wind correction function
        out[[i]] <- wind_correction(dt, TPA, TPI)
}

out[[1752]]

inputs[1752]

dat <- do.call(rbind, out)

dat %>% 
        dplyr::select(waf, Wind_corrected_rx, Wind_corrected_50, Wind_corrected_97) %>% is.na() %>% sum()
```

# WAF error

The WAF error stems from there no spatial inputs being loaded. 
Find how many of the input tiles are empty

```{r}
empties <- list()

for (i in 1:length(inputs)) {
        t <- read_rds(inputs[i])
        if (nrow(t) == 0) {
                empties[[i]] <- inputs[i]
        }   
}

do.call(rbind, empties)


r <- str_subset(inputs, pattern = "6055") %>% 
        read_rds()
r

r <- raster::rasterFromXYZ(select(r, c(x,y,FCID2018)), crs = "+proj=aea +lat_1=34 +lat_2=40.5 +lat_0=0 +lon_0=-120 +x_0=0 +y_0=-4000000 +datum=NAD83 +units=m +no_defs +ellps=GRS80 +towgs84=0,0,0 ")

getwd()
#raster::writeRaster(r, filename = "tile6055.tif")
```


```{r}
 # make a nested list of wind adjustment factors
waf_dict <- list("ridge" = list("unsheltered" = 0.5,
                                        "partially_sheltered" = 0.4,
                                        "sheltered" = 0.3),
                         "upper_slope" = list("unsheltered" = 0.5,
                                              "partially_sheltered" = 0.4,
                                              "sheltered" = 0.3),
                         "lower_slope" = list("unsheltered" = 0.5,
                                              "partially_sheltered" = 0.3,
                                              "sheltered" = 0.2),
                         "valley" = list("unsheltered" = 0.5,
                                         "partially_sheltered" = 0.2,
                                         "sheltered" = 0.1))

make_waf <- function(lf_class, shelter_class) {
                z <- lapply(seq(1:length(lf_class)), function(i)
                        waf_dict[[lf_class[i]]][[shelter_class[i]]])
                
                return(unlist(z))
}

wind_correction <- function(dt, Wind, TPA, TPI) {
        # write function to access waf_dict for each row based on lf_class and shelter class
        
        # classify landform based on terrain prominence
        dt[, lf_class := ifelse(TPI < -0.5, "valley", 
                                ifelse(TPI >= -0.5 & TPI < 0, 
                                       "lower_slope",
                                       ifelse(TPI >= 0 & TPI < 0.5,
                                              "upper_slope",
                                              "ridge")))]
        
        # classify shelter based on tpa
        dt[, shelter_class := ifelse(TPA <= 10, 
                                     "unsheltered",
                                     ifelse(TPA > 10 & TPA <= 100,
                                            "partially_sheltered",
                                            "sheltered"))]
        
        # get waf
        dt[, waf := make_waf(lf_class, shelter_class)]
        
        
        # add stop into function see where waf is not being made
        if (nrow(dt) == 0) {
                stop("Error: waf not found for tile: ", print(i))
        }
        
        # correct windspeed
        # dt[, ':=' (Wind_corrected_rx = Wind_rx * waf,
        #            Wind_corrected_50 = Wind_50 * waf,
        #            Wind_corrected_97 = Wind_97 * waf)]
        
        # remove old columns
        #dt[, c("lf_class", "shelter_class", "waf") := NULL ]
        return(dt)
        
}

```






## scratch outputs function step througha

```{r}

fuel_df %>% 
        filter(fuelbed_number == 213)

dt %>% 
        filter(fuelbed_number == 213)

# check mass after add residue script
fuel_df
fuel_df %>% 
        summarise_at(.vars = c("Stem_6t9_tonsAcre", "Stem_4t6_tonsAcre", "Stem_ge9_tonsAcre", "Branch_tonsAcre", "Foliage_tonsAcre"), .funs = sum) %>% 
        rowSums()

dt
```
```{r}
 dt[, ':=' (Wind_corrected = Wind_corrected_rx,
                                                  Fm10  = Fm10_rx,
                                                  Fm1000 = Fm1000_rx)]
```

```{r}
dt %>% 
        filter(fuelbed_number == 213) %>% 
        select(ffr, litter_reduction, litter_loading, litter_proportional_reduction, total_litter)
```

```{r}
dt %>% 
        filter(fuelbed_number == 213) %>% 
        select(duff_proportional_reduction, ffr_errorflag, duff_upper_depth, total_duff)

size
dt %>% 
        filter(fuelbed_number == 213) %>% 
        select(duff_depth, ffr)
```

